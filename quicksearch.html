<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" @wfcd/arsenal-parser Classes module.exports#module.exports Global mapColorspositionsafeColor Source: utils.js 'use strict'; const Items = require('warframe-items'); const Pixel = require('./Pixel'); const items = new Items(); function translateFocus(focus = '') { if (focus.includes('Focus/Attack')) { return 'Madurai'; } if (focus.includes('Focus/Defense')) { return 'Varazin'; } if (focus.includes('Focus/Tactic')) { return 'Naramon'; } if (focus.includes('Focus/Power')) { return 'Zenurik'; } if (focus.includes('Focus/Ward')) { return 'Unairu'; } return 'None'; } function translatePolarity(pol = '') { if (pol.includes('AP_ATTACK')) { return 'Madurai'; } if (pol.includes('AP_DEFENSE')) { return 'Varazin'; } if (pol.includes('AP_TACTIC')) { return 'Naramon'; } if (pol.includes('AP_POWER')) { return 'Zenurik'; } if (pol.includes('AP_WARD')) { return 'Unairu'; } return 'None'; } function loadMods(upgrades = []) { const arcanes = []; const mods = []; upgrades.forEach((upgrade) =&gt; { let upgradeData = items.find((item) =&gt; item.uniqueName === upgrade.uniqueName) || upgrade; upgradeData.rank = upgrade.rank; upgradeData.uniqueName = upgrade.uniqueName; if (upgradeData.levelStats) { upgradeData.levelStats = upgradeData.levelStats[upgrade.rank] || upgradeData.levelStats; } delete upgradeData.drops; delete upgradeData.patchlogs; if (upgradeData.category === 'Arcanes') { delete upgradeData.tradable; arcanes.push(upgradeData); } else if (upgradeData.category === 'Mods') { if (upgradeData.name.includes('Riven Mod')) { upgradeData = { uniqueName: upgradeData.uniqueName, polarity: translatePolarity(upgrade.pol), rarity: upgradeData.rarity, baseDrain: Number(upgradeData.baseDrain), fusionLimit: upgradeData.fusionLimit, imageName: upgradeData.imageName, category: upgradeData.category, tradable: upgradeData.tradable, wikiaThumbnail: upgradeData.wikiaThumbnail || undefined, wikiaUrl: upgradeData.wikiaUrl || undefined, buffs: upgrade.buffs, curses: upgrade.curses, masteryReq: upgrade.lvlReq, }; } delete upgradeData.transmutable; delete upgradeData.tradable; mods.push(upgradeData); } }); return { arcanes, mods, }; } /** * Safely map a color to a pixel * @param {string|undefined} color hex value to check for existence * @returns {Pixel|undefined} */ const safeColor = (color) =&gt; (color ? new Pixel(color) : undefined); /** * Common Color Map * @typedef {Object} ColorMap * @property {Pixel} [primary] * @property {Pixel} [secondary] * @property {Pixel} [tertiary] * @property {Pixel} [accents] * @property {Array&lt;Pixel&gt;} [emissive] * @property {Array&lt;Pixel&gt;} [energy] */ /** * @typedef {Object} RawColors * @property {string} [t0] primary color hex * @property {string} [t1] secondary color hex * @property {string} [t2] tertiary color hex * @property {string} [t3] accent color hex * @property {string} [m0] first emissive color hex * @property {string} [m1] second emissive color hex * @property {string} [en] first energy color hex * @property {string} [en1] second energy color hex */ /** * Map DE Colors to common named colors * @param {RawColors} colors raw colors from api * @returns {ColorMap|undefined} */ function mapColors(colors = undefined) { if (!colors) return undefined; return { primary: safeColor(colors.t0), secondary: safeColor(colors.t1), tertiary: safeColor(colors.t2), accents: safeColor(colors.t3), emissive: [safeColor(colors.m0), safeColor(colors.m1)].filter((c) =&gt; c), energy: [safeColor(colors.en), safeColor(colors.en1)].filter((c) =&gt; c), }; } const findItem = (uname) =&gt; items .filter((item) =&gt; item &amp;&amp; typeof item !== 'undefined' &amp;&amp; item.uniqueName) .find((item) =&gt; item.uniqueName === uname); module.exports = { translateFocus, loadMods, translatePolarity, items, findItem, mapColors, }; × Search results Close "},"Player.js.html":{"id":"Player.js.html","title":"Source: Player.js","body":" @wfcd/arsenal-parser Classes module.exports#module.exports Global mapColorspositionsafeColor Source: Player.js 'use strict'; const { translateFocus, items } = require('./utils'); module.exports = /** Warframe Player information */ class WarframePlayer { /** * Player name * @type {string} */ #name; /** * Player mastery rank * @type {number} */ #masteryRank; /** * Last updated date/time * @type {Date} */ #lastUpdated; /** * Glyph item * @type {Item} */ #glyph; /** * Currently selected focus school * @type {string} */ #focusSchool; constructor(data) { this.#name = data.playerName; this.#masteryRank = data.masteryRank; this.#lastUpdated = new Date(data.lastUpdated * 1000); this.#glyph = items.find((item) =&gt; item.uniqueName === data.glyph) || data.glyph; this.#focusSchool = translateFocus(data.focus || ''); } /** * Player name * @returns {string} */ get name() { return this.#name; } /** * Player mastery rank * @returns {number} */ get masteryRank() { return this.#masteryRank; } /** * Last updated date/time * @returns {Date} */ get lastUpdated() { return this.#lastUpdated; } /** * Glyph item * @returns {Item} */ get glyph() { return this.#glyph; } /** * Currently selected focus school * @returns {string} */ get focusSchool() { return this.#focusSchool; } toJSON() { return { name: this.#name, masteryRank: this.#masteryRank, lastUpdated: this.#lastUpdated, glyph: this.#glyph, focusSchool: this.#focusSchool, }; } }; × Search results Close "},"Pixel.js.html":{"id":"Pixel.js.html","title":"Source: Pixel.js","body":" @wfcd/arsenal-parser Classes module.exports#module.exports Global mapColorspositionsafeColor Source: Pixel.js 'use strict'; const Items = require('warframe-items'); const items = new Items().filter((i) =&gt; i.hexColours); /** * Palette Coordinate representation * @typedef {Object} PaletteCoordinate * @property {number} row row in palette to which this coordinate corresponds * @property {number} col column in palette to which this coordinate corresponds */ /** * Determine row/column from an index * @param {number} [ind] array index of a coordinate * @returns {PaletteCoordinate} */ const position = (ind) =&gt; ({ row: (ind % 18) + 1, col: Math.ceil(ind / 18), }); /** * Generic palette descriptor * @typedef {Object} Palette * @property {string} name Palette name (as seen in-game) * @property {string} description Description of the palette */ /** * Palette Entry * @typedef {Object} PaletteEntry * @property {Palette} palette * @property {PaletteCoordinate} */ module.exports = class Pixel { /** Raw hex value * @type string */ #hex; /** * Matching palette entries * @type {Array&lt;PaletteEntry&gt;} */ #matches = []; /** * Matched palette list of names * @type {Array&lt;string&gt;} */ #palettes = []; /** * Whether this pixel is transparent * @type {boolean} */ #isTransparent = false; /** * Generate a pixel descriptive object * @param {string} hex string-represented hex code * @constructor */ constructor(hex) { this.#hex = hex; this.#isTransparent = hex === '0'; if (!this.#isTransparent) { this.#isTransparent = undefined; items.forEach(({ name, description, hexColours }) =&gt; { hexColours.forEach(({ value }, index) =&gt; { if (value.toLowerCase().includes(hex.toLowerCase())) { if (!this.#palettes.includes(name)) { this.#matches.push({ palette: { name, description }, position: position(index), }); this.#palettes.push(name); } } }); }); } } /** * Palette within the * @returns {Array&lt;string&gt;} */ get palettes() { return this.#palettes; } /** * Pixel Coordinate matches * @returns {Array&lt;PaletteEntry&gt;} */ get matches() { return this.#matches; } /** * Whether this pixel is transparent * @returns {boolean} */ get isTransparent() { return this.#isTransparent; } get hex() { return this.#hex; } toJSON() { return { matches: this.#matches, isTransparent: this.#isTransparent, hex: this.#hex, }; } }; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" @wfcd/arsenal-parser Classes module.exports#module.exports Global mapColorspositionsafeColor Global Methods mapColors(colors) Map DE Colors to common named colors Parameters: Name Type Description colors RawColors raw colors from api Source: utils.js, line 128 Returns: Type ColorMap | undefined position( [ind]) Determine row/column from an index Parameters: Name Type Argument Description ind number &lt;optional&gt; array index of a coordinate Source: Pixel.js, line 19 Returns: Type PaletteCoordinate safeColor(color) Safely map a color to a pixel Parameters: Name Type Description color string | undefined hex value to check for existence Source: utils.js, line 98 Returns: Type Pixel | undefined Type Definitions ColorMap Common Color Map Type: Object Properties: Name Type Argument Description primary Pixel &lt;optional&gt; secondary Pixel &lt;optional&gt; tertiary Pixel &lt;optional&gt; accents Pixel &lt;optional&gt; emissive Array.&lt;Pixel&gt; &lt;optional&gt; energy Array.&lt;Pixel&gt; &lt;optional&gt; Source: utils.js, line 100 Palette Generic palette descriptor Type: Object Properties: Name Type Description name string Palette name (as seen in-game) description string Description of the palette Source: Pixel.js, line 24 PaletteCoordinate Palette Coordinate representation Type: Object Properties: Name Type Description row number row in palette to which this coordinate corresponds col number column in palette to which this coordinate corresponds Source: Pixel.js, line 7 PaletteEntry Palette Entry Type: Object Properties: Name Type Description palette Palette PaletteCoordinate Source: Pixel.js, line 30 RawColors Type: Object Properties: Name Type Argument Description t0 string &lt;optional&gt; primary color hex t1 string &lt;optional&gt; secondary color hex t2 string &lt;optional&gt; tertiary color hex t3 string &lt;optional&gt; accent color hex m0 string &lt;optional&gt; first emissive color hex m1 string &lt;optional&gt; second emissive color hex en string &lt;optional&gt; first energy color hex en1 string &lt;optional&gt; second energy color hex Source: utils.js, line 111 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" @wfcd/arsenal-parser Classes module.exports#module.exports Global mapColorspositionsafeColor Classes Classes exports × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" @wfcd/arsenal-parser Classes module.exports#module.exports Global mapColorspositionsafeColor Arsenal Parser Parse the Warframe Arsenal Twitch extension data into useable javascript objects. Documentation is available here Example usage const ArsenalData = require('ArsenalParser'); const fetch = require('node-fetch'); const baseURL = 'https://content.warframe.com/dynamic/twitch/getActiveLoadout.php?account='; async function fetchArsenal(username) { // Fetch the data for the specified username const data = await fetch(baseURL + encodeURIComponent(username.toLowerCase())) .then((res) =&gt; res.json()); if (data.errors) { throw new Error(data.errors); } return new ArsenalData(data); } × Search results Close "},"module.exports_module.exports.html":{"id":"module.exports_module.exports.html","title":"Class: exports","body":" @wfcd/arsenal-parser Classes module.exports#module.exports Global mapColorspositionsafeColor Class: exports exports new exports(hex) Generate a pixel descriptive object Parameters: Name Type Description hex string string-represented hex code Source: Pixel.js, line 63 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
